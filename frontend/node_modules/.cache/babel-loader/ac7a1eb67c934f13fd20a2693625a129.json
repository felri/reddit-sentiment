{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nimport { useCallback, useMemo, useEffect } from 'react';\nimport ReactDOM from 'react-dom';\nimport { useSelector } from 'react-redux';\nimport { createSelector } from 'reselect';\nimport debounce from 'lodash/debounce';\nimport union from 'lodash/union';\nimport isEqual from 'lodash/isEqual';\nimport get from 'lodash/get';\nimport { CRUD_GET_MANY } from '../actions/dataActions/crudGetMany';\nimport { useSafeSetState } from '../util/hooks';\nimport useDataProvider from './useDataProvider';\nimport { useVersion } from '../controller';\nvar queriesToCall = {};\nvar dataProvider;\nvar DataProviderOptions = {\n  action: CRUD_GET_MANY\n};\n/**\n * Call the dataProvider.getMany() method and return the resolved result\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { loading: true, loaded: false, refetch }\n * - success: { data: [data from response], loading: false, loaded: true, refetch }\n * - error: { error: [error from response], loading: false, loaded: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * This hook aggregates and deduplicates calls to the same resource, so for instance, if an app calls:\n *\n * useGetMany('tags', [1, 2, 3]);\n * useGetMany('tags', [3, 4]);\n *\n * during the same tick, the hook will only call the dataProvider once with the following parameters:\n *\n * dataProvider(GET_MANY, 'tags', [1, 2, 3, 4])\n *\n * @param resource The resource name, e.g. 'posts'\n * @param ids The resource identifiers, e.g. [123, 456, 789]\n * @param {Object} options Options object to pass to the dataProvider.\n * @param {boolean} options.enabled Flag to conditionally run the query. If it's false, the query will not run\n * @param {Function} options.onSuccess Side effect function to be executed upon success, e.g. { onSuccess: { refresh: true } }\n * @param {Function} options.onFailure Side effect function to be executed upon failure, e.g. { onFailure: error => notify(error.message) }\n *\n * @returns The current request state. Destructure as { data, error, loading, loaded, refetch }.\n *\n * @example\n *\n * import { useGetMany } from 'react-admin';\n *\n * const PostTags = ({ record }) => {\n *     const { data, loading, error } = useGetMany('tags', record.tagIds);\n *     if (loading) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return (\n *          <ul>\n *              {data.map(tag => (\n *                  <li key={tag.id}>{tag.name}</li>\n *              ))}\n *          </ul>\n *      );\n * };\n */\n\nvar useGetMany = function (resource, ids, options) {\n  var _a;\n\n  if (options === void 0) {\n    options = {\n      enabled: true\n    };\n  } // we can't use useQueryWithStore here because we're aggregating queries first\n  // therefore part of the useQueryWithStore logic will have to be repeated below\n\n\n  var selectMany = useMemo(makeGetManySelector, []);\n  var data = useSelector(function (state) {\n    return selectMany(state, resource, ids);\n  });\n  var version = useVersion(); // used to allow force reload\n  // used to force a refetch without relying on version\n  // which might trigger other queries as well\n\n  var _b = useSafeSetState(0),\n      innerVersion = _b[0],\n      setInnerVersion = _b[1];\n\n  var refetch = useCallback(function () {\n    setInnerVersion(function (prevInnerVersion) {\n      return prevInnerVersion + 1;\n    });\n  }, [setInnerVersion]);\n\n  var _c = useSafeSetState({\n    data: data,\n    error: null,\n    loading: ids.length !== 0,\n    loaded: data.length !== 0 && !data.includes(undefined),\n    refetch: refetch\n  }),\n      state = _c[0],\n      setState = _c[1];\n\n  if (!isEqual(state.data, data)) {\n    var newState = __assign(__assign({}, state), {\n      data: (data === null || data === void 0 ? void 0 : data.includes(undefined)) ? state.data : data,\n      loading: ((_a = state.data) === null || _a === void 0 ? void 0 : _a.length) !== 0 && (state.loading || (data === null || data === void 0 ? void 0 : data.includes(undefined)))\n    });\n\n    if (!isEqual(state, newState)) {\n      setState(newState);\n    }\n  }\n\n  dataProvider = useDataProvider(); // not the best way to pass the dataProvider to a function outside the hook, but I couldn't find a better one\n\n  useEffect(function () {\n    if (options.enabled === false) {\n      return;\n    }\n\n    if (!queriesToCall[resource]) {\n      queriesToCall[resource] = [];\n    }\n    /**\n     * queriesToCall stores the queries to call under the following shape:\n     *\n     * {\n     *   'posts': [\n     *     { ids: [1, 2], setState }\n     *     { ids: [2, 3], setState, onSuccess }\n     *     { ids: [4, 5], setState }\n     *   ],\n     *   'comments': [\n     *     { ids: [345], setState, onFailure }\n     *   ]\n     * }\n     */\n\n\n    queriesToCall[resource] = queriesToCall[resource].concat({\n      ids: ids,\n      setState: setState,\n      onSuccess: options && options.onSuccess,\n      onFailure: options && options.onFailure\n    });\n    callQueries(); // debounced by lodash\n  },\n  /* eslint-disable react-hooks/exhaustive-deps */\n  [JSON.stringify({\n    resource: resource,\n    ids: ids,\n    options: options,\n    version: version,\n    innerVersion: innerVersion\n  }), dataProvider]\n  /* eslint-enable react-hooks/exhaustive-deps */\n  );\n  return state;\n};\n/**\n * Memoized selector for getting an array of resources based on an array of ids\n *\n * @see https://react-redux.js.org/next/api/hooks#using-memoizing-selectors\n */\n\n\nvar makeGetManySelector = function () {\n  return createSelector([function (state, resource) {\n    return get(state, ['admin', 'resources', resource, 'data']);\n  }, function (_, __, ids) {\n    return ids;\n  }], function (resourceData, ids) {\n    return resourceData ? ids.map(function (id) {\n      return resourceData[id];\n    }) : ids.map(function (id) {\n      return undefined;\n    });\n  });\n};\n/**\n * Call the dataProvider once per resource\n */\n\n\nvar callQueries = debounce(function () {\n  var resources = Object.keys(queriesToCall);\n  resources.forEach(function (resource) {\n    var queries = __spreadArray([], queriesToCall[resource], true); // cloning to avoid side effects\n\n    /**\n     * Extract ids from queries, aggregate and deduplicate them\n     *\n     * @example from [[1, 2], [2, null, 3], [4, null]] to [1, 2, 3, 4]\n     */\n\n\n    var accumulatedIds = queries.reduce(function (acc, _a) {\n      var ids = _a.ids;\n      return union(acc, ids);\n    }, []) // concat + unique\n    .filter(function (v) {\n      return v != null && v !== '';\n    }); // remove null values\n\n    if (accumulatedIds.length === 0) {\n      // no need to call the data provider if all the ids are null\n      queries.forEach(function (_a) {\n        var ids = _a.ids,\n            setState = _a.setState,\n            onSuccess = _a.onSuccess;\n        setState({\n          data: emptyArray,\n          loading: false,\n          loaded: true\n        });\n\n        if (onSuccess) {\n          onSuccess({\n            data: emptyArray\n          });\n        }\n      });\n      return;\n    }\n\n    dataProvider.getMany(resource, {\n      ids: accumulatedIds\n    }, DataProviderOptions).then(function (response) {\n      // Forces batching, see https://stackoverflow.com/questions/48563650/does-react-keep-the-order-for-state-updates/48610973#48610973\n      return ReactDOM.unstable_batchedUpdates(function () {\n        return queries.forEach(function (_a) {\n          var ids = _a.ids,\n              setState = _a.setState,\n              onSuccess = _a.onSuccess;\n          setState(function (prevState) {\n            return __assign(__assign({}, prevState), {\n              error: null,\n              loading: false,\n              loaded: true\n            });\n          });\n\n          if (onSuccess) {\n            var subData = ids.map(function (id) {\n              return response.data.find(function (datum) {\n                return datum.id == id;\n              });\n            } // eslint-disable-line eqeqeq\n            );\n            onSuccess({\n              data: subData\n            });\n          }\n        });\n      });\n    }).catch(function (error) {\n      return ReactDOM.unstable_batchedUpdates(function () {\n        return queries.forEach(function (_a) {\n          var setState = _a.setState,\n              onFailure = _a.onFailure;\n          setState({\n            error: error,\n            loading: false,\n            loaded: false\n          });\n          onFailure && onFailure(error);\n        });\n      });\n    });\n    delete queriesToCall[resource];\n  });\n});\nvar emptyArray = [];\nexport default useGetMany;","map":{"version":3,"sources":["/app/node_modules/ra-core/esm/dataProvider/useGetMany.js"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","__spreadArray","to","from","pack","l","ar","Array","slice","concat","useCallback","useMemo","useEffect","ReactDOM","useSelector","createSelector","debounce","union","isEqual","get","CRUD_GET_MANY","useSafeSetState","useDataProvider","useVersion","queriesToCall","dataProvider","DataProviderOptions","action","useGetMany","resource","ids","options","_a","enabled","selectMany","makeGetManySelector","data","state","version","_b","innerVersion","setInnerVersion","refetch","prevInnerVersion","_c","error","loading","loaded","includes","undefined","setState","newState","onSuccess","onFailure","callQueries","JSON","stringify","_","__","resourceData","map","id","resources","keys","forEach","queries","accumulatedIds","reduce","acc","filter","v","emptyArray","getMany","then","response","unstable_batchedUpdates","prevState","subData","find","datum","catch"],"mappings":"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","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { useCallback, useMemo, useEffect } from 'react';\nimport ReactDOM from 'react-dom';\nimport { useSelector } from 'react-redux';\nimport { createSelector } from 'reselect';\nimport debounce from 'lodash/debounce';\nimport union from 'lodash/union';\nimport isEqual from 'lodash/isEqual';\nimport get from 'lodash/get';\nimport { CRUD_GET_MANY } from '../actions/dataActions/crudGetMany';\nimport { useSafeSetState } from '../util/hooks';\nimport useDataProvider from './useDataProvider';\nimport { useVersion } from '../controller';\nvar queriesToCall = {};\nvar dataProvider;\nvar DataProviderOptions = { action: CRUD_GET_MANY };\n/**\n * Call the dataProvider.getMany() method and return the resolved result\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { loading: true, loaded: false, refetch }\n * - success: { data: [data from response], loading: false, loaded: true, refetch }\n * - error: { error: [error from response], loading: false, loaded: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * This hook aggregates and deduplicates calls to the same resource, so for instance, if an app calls:\n *\n * useGetMany('tags', [1, 2, 3]);\n * useGetMany('tags', [3, 4]);\n *\n * during the same tick, the hook will only call the dataProvider once with the following parameters:\n *\n * dataProvider(GET_MANY, 'tags', [1, 2, 3, 4])\n *\n * @param resource The resource name, e.g. 'posts'\n * @param ids The resource identifiers, e.g. [123, 456, 789]\n * @param {Object} options Options object to pass to the dataProvider.\n * @param {boolean} options.enabled Flag to conditionally run the query. If it's false, the query will not run\n * @param {Function} options.onSuccess Side effect function to be executed upon success, e.g. { onSuccess: { refresh: true } }\n * @param {Function} options.onFailure Side effect function to be executed upon failure, e.g. { onFailure: error => notify(error.message) }\n *\n * @returns The current request state. Destructure as { data, error, loading, loaded, refetch }.\n *\n * @example\n *\n * import { useGetMany } from 'react-admin';\n *\n * const PostTags = ({ record }) => {\n *     const { data, loading, error } = useGetMany('tags', record.tagIds);\n *     if (loading) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return (\n *          <ul>\n *              {data.map(tag => (\n *                  <li key={tag.id}>{tag.name}</li>\n *              ))}\n *          </ul>\n *      );\n * };\n */\nvar useGetMany = function (resource, ids, options) {\n    var _a;\n    if (options === void 0) { options = { enabled: true }; }\n    // we can't use useQueryWithStore here because we're aggregating queries first\n    // therefore part of the useQueryWithStore logic will have to be repeated below\n    var selectMany = useMemo(makeGetManySelector, []);\n    var data = useSelector(function (state) {\n        return selectMany(state, resource, ids);\n    });\n    var version = useVersion(); // used to allow force reload\n    // used to force a refetch without relying on version\n    // which might trigger other queries as well\n    var _b = useSafeSetState(0), innerVersion = _b[0], setInnerVersion = _b[1];\n    var refetch = useCallback(function () {\n        setInnerVersion(function (prevInnerVersion) { return prevInnerVersion + 1; });\n    }, [setInnerVersion]);\n    var _c = useSafeSetState({\n        data: data,\n        error: null,\n        loading: ids.length !== 0,\n        loaded: data.length !== 0 && !data.includes(undefined),\n        refetch: refetch,\n    }), state = _c[0], setState = _c[1];\n    if (!isEqual(state.data, data)) {\n        var newState = __assign(__assign({}, state), { data: (data === null || data === void 0 ? void 0 : data.includes(undefined)) ? state.data : data, loading: ((_a = state.data) === null || _a === void 0 ? void 0 : _a.length) !== 0 &&\n                (state.loading || (data === null || data === void 0 ? void 0 : data.includes(undefined))) });\n        if (!isEqual(state, newState)) {\n            setState(newState);\n        }\n    }\n    dataProvider = useDataProvider(); // not the best way to pass the dataProvider to a function outside the hook, but I couldn't find a better one\n    useEffect(function () {\n        if (options.enabled === false) {\n            return;\n        }\n        if (!queriesToCall[resource]) {\n            queriesToCall[resource] = [];\n        }\n        /**\n         * queriesToCall stores the queries to call under the following shape:\n         *\n         * {\n         *   'posts': [\n         *     { ids: [1, 2], setState }\n         *     { ids: [2, 3], setState, onSuccess }\n         *     { ids: [4, 5], setState }\n         *   ],\n         *   'comments': [\n         *     { ids: [345], setState, onFailure }\n         *   ]\n         * }\n         */\n        queriesToCall[resource] = queriesToCall[resource].concat({\n            ids: ids,\n            setState: setState,\n            onSuccess: options && options.onSuccess,\n            onFailure: options && options.onFailure,\n        });\n        callQueries(); // debounced by lodash\n    }, \n    /* eslint-disable react-hooks/exhaustive-deps */\n    [\n        JSON.stringify({\n            resource: resource,\n            ids: ids,\n            options: options,\n            version: version,\n            innerVersion: innerVersion,\n        }),\n        dataProvider,\n    ]\n    /* eslint-enable react-hooks/exhaustive-deps */\n    );\n    return state;\n};\n/**\n * Memoized selector for getting an array of resources based on an array of ids\n *\n * @see https://react-redux.js.org/next/api/hooks#using-memoizing-selectors\n */\nvar makeGetManySelector = function () {\n    return createSelector([\n        function (state, resource) {\n            return get(state, ['admin', 'resources', resource, 'data']);\n        },\n        function (_, __, ids) { return ids; },\n    ], function (resourceData, ids) {\n        return resourceData\n            ? ids.map(function (id) { return resourceData[id]; })\n            : ids.map(function (id) { return undefined; });\n    });\n};\n/**\n * Call the dataProvider once per resource\n */\nvar callQueries = debounce(function () {\n    var resources = Object.keys(queriesToCall);\n    resources.forEach(function (resource) {\n        var queries = __spreadArray([], queriesToCall[resource], true); // cloning to avoid side effects\n        /**\n         * Extract ids from queries, aggregate and deduplicate them\n         *\n         * @example from [[1, 2], [2, null, 3], [4, null]] to [1, 2, 3, 4]\n         */\n        var accumulatedIds = queries\n            .reduce(function (acc, _a) {\n            var ids = _a.ids;\n            return union(acc, ids);\n        }, []) // concat + unique\n            .filter(function (v) { return v != null && v !== ''; }); // remove null values\n        if (accumulatedIds.length === 0) {\n            // no need to call the data provider if all the ids are null\n            queries.forEach(function (_a) {\n                var ids = _a.ids, setState = _a.setState, onSuccess = _a.onSuccess;\n                setState({\n                    data: emptyArray,\n                    loading: false,\n                    loaded: true,\n                });\n                if (onSuccess) {\n                    onSuccess({ data: emptyArray });\n                }\n            });\n            return;\n        }\n        dataProvider\n            .getMany(resource, { ids: accumulatedIds }, DataProviderOptions)\n            .then(function (response) {\n            // Forces batching, see https://stackoverflow.com/questions/48563650/does-react-keep-the-order-for-state-updates/48610973#48610973\n            return ReactDOM.unstable_batchedUpdates(function () {\n                return queries.forEach(function (_a) {\n                    var ids = _a.ids, setState = _a.setState, onSuccess = _a.onSuccess;\n                    setState(function (prevState) { return (__assign(__assign({}, prevState), { error: null, loading: false, loaded: true })); });\n                    if (onSuccess) {\n                        var subData = ids.map(function (id) {\n                            return response.data.find(function (datum) { return datum.id == id; });\n                        } // eslint-disable-line eqeqeq\n                        );\n                        onSuccess({ data: subData });\n                    }\n                });\n            });\n        })\n            .catch(function (error) {\n            return ReactDOM.unstable_batchedUpdates(function () {\n                return queries.forEach(function (_a) {\n                    var setState = _a.setState, onFailure = _a.onFailure;\n                    setState({ error: error, loading: false, loaded: false });\n                    onFailure && onFailure(error);\n                });\n            });\n        });\n        delete queriesToCall[resource];\n    });\n});\nvar emptyArray = [];\nexport default useGetMany;\n"]},"metadata":{},"sourceType":"module"}